/**
* @file PermutationCipher.h
* @author Авдонин А.Д.
* @version 1.0
* @brief Описание класса PermutationCipher
* @date 20.05.2021
* @copyright ИБСТ ПГУ
*/

#pragma once
#include <string>
using namespace std;
/// @brief Класс для шифрования и расшифрования шифра табличной маршрутной перестановки
class PermutationCipher
{
private:
    /// @brief атрибут, хранящий ключ для шифрования или расшифрования
    int key;
public:
    /// @brief Запрещающий конструктор без параметров
    PermutationCipher() = delete;
    /// @brief Конструктор для ключа
     /**@param целочисленное число ключ
     * @details число, которое пришло на вход записывается в "private" атрибут с названием "key"
     */
    PermutationCipher(int k);
    /** @brief Метод , предназначенный для шифрования шифром табличной маршрутной перестановки
     *@param экземляр класса "PermutationCipher", в котором установился ключ
     *@param std::wstring - строка, которую нужно зашифровать
     * @details
     * <p>Сначала вычисляется количество строк для таблицы по формуле.
     * @code
     * const int stroki = ((data.size()-1)/key.key)+1; // количество строк по формуле
     *@endcode
     * Затем создаётся двумерный массив типа "wchar_t", который имеет необходимый размер:
     * количество строк вычисляется по формуле, а количество столбцов - это ключ, который устанавливается в экземляре класса "PermutationCipher".</p>
     * @code
     * wchar_t matr[stroki][key.key];
     *@endcode
     * <p>Далее в созданный двумерный массив записываются символы строки, которую нужно зашифровать. Запись символов просходит по следующему
     * маршруту: слева-направа.  То есть, запись происходит по строкам.
     * @code
     * for (auto i = 0; i <stroki; i++) {
     *  for (auto j = 0; j < key.key; j++ ) {
     *     }
     * }
     *@endcode
     * Примечение - если в таблице остаются незаполненные "ячейки", то в них записыватеся символ "пробела". Такая ситуации может произойти,
     * если длина строки, которая пришла на вход не кратна значению ключа.
     *@code
     * if (index < data.size()) {
     *       matr[i][j] = data[index]; // записываем символы строки в таблицу (слева-направо)
     *       index++;
     *      } else {
     *           matr[i][j] =' ';
     *      }
     *@endcode
     *</p>
     * <p>В конечном итоге происходит процесс шифрования. Он заключается в том, что символы, которые находятся в двумерном массиве записываются в строку типа
     * wstring с именем "Result" по следующему маршруту: сверху-вниз. То есть, чтение происходит по столбцам.
     * @code
     * for (auto i = 0; i < key.key; i++) {
     *   for (auto j = 0; j < stroki; j++ ) {
     *       if (index <= data.size())
     *          Result.push_back(matr[j][i]);
     *           index++;
     *      }
     *   }
     * @endcode
     *</p>
     * @return зашифрованная строка типа "wstring"
     */
    wstring EncodePermutationCipher(PermutationCipher key, wstring &data);
    /** @brief Метод , предназначенный для расшифрования шифра табличной маршрутной перестановки
     *@param экземляр класса "PermutationCipher", в котором установился ключ
     *@param std::wstring - строка, которую нужно расшифровать
     * @details
     * <p>Сначала вычисляется количество строк для таблицы по формуле.
     * @code
     * const int stroki = ((data.size()-1)/key.key)+1; // количество строк по формуле
     *@endcode
     * Затем создаётся двумерный массив типа "wchar_t", который имеет необходимый размер:
     * количество строк вычисляется по формуле, а количество столбцов - это ключ, который устанавливается в экземляре класса "PermutationCipher".</p>
     * @code
     * wchar_t matr[stroki][key.key];
     *@endcode
     * <p>Далее в созданный двумерный массив записываются символы строки, которую нужно расшифровать. Запись символов просходит по следующему
     * маршруту: сверху-вниз. То есть, запись происходит по столбцам.
     * @code
     * for (auto i = 0; i < key.key; i++) {
     *  for (auto j = 0; j < stroki; j++ ) {
     *      }
     * }
     *@endcode
     * Примечение - если в таблице остаются незаполненные "ячейки", то в них записыватеся символ "пробела". Такая ситуации может произойти,
     * если длина строки, которая пришла на вход не кратна значению ключа.
     *@code
     * if (index < data.size()) {
     *           matr[j][i] = data[index];
     *           index++;
     *       } else {
     *           matr[j][i] = ' ';
     *           index++;
     *      }
     *@endcode
     *</p>
     * <p>В конечном итоге происходит процесс расшифрования. Он заключается в том, что символы, которые находятся в двумерном массиве записываются в строку типа
     * wstring с именем "Result" по следующему маршруту: слева-направа. То есть, чтение происходит по строкам.
     * @code
     * for(auto i = 0; i < stroki; i++) {
     *   for (auto j = 0; j< key.key; j++) {
     *       if (index<data.size())
     *           Result.push_back(matr[i][j]);
     *          index++;
     *     }
     *   }
     * @endcode
     *</p>
     * @return расшифрованная строка типа "wstring"
     */
    wstring DecodePermutationCipher(PermutationCipher key, wstring &data);
};
